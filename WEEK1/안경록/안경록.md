프로그래밍 언어란 어떤 것일까요?
프로그래밍 언어란 컴퓨터 프로그램을 작성하기 위한 언어입니다. 다른 말로는 소프트웨어의 동작을 설명하기 위한 언어이죠.
이 프로그래밍 언어를 사용해 프로그램을 개발하는 행위를 프로그래밍 이라고 합니다.

컴파일 언어와 인터프리터 언어?

컴파일 언어 : 소스 코드 여러 개를 하나로 묶어서 컴파일한 후에 실행하는 프로그래밍 언어 (C,C++,Java,Object C..)

인터프리터 언어 : 프로그램을 한 줄마다 기계어로 번역해서 실행하는 프로그래밍 언어, 이때 번역해주는 주체인 소프트웨어를 인터프리터라고한다. 인터프리터 언어는 프로그램을 바로 실행할 수 있고 동작을 확인해가면서 프로그램을 개발 할 수 있지만 컴파일 언어보다 처리 속도가 느리다는 단점이 존재한다. (Javascript, Ruby, Python...)

프로그래밍 언어의 유형
프로그램을 만들어 가는 방식에 따라서도 프로그래밍 언어를 분류할 수 있는데요.

절차적 언어 : 절차를 순서대로 작성
객체 지향 언어 : 처리와 관련된 데이터와 절차를 하나로 묶어 객체 단위로 관리
함수형 언어 : 프로그램 함수를 조합하여 구현해 나감
논리형 언어 : 데이터 사이의 관계와 논리를 설명해 나감

자바 스크립트는 객체 지향 언어지만 함수형 언어의 특징도 가지고 있습니다.

자바스크립트의 특징

1. 인터프리터 언어이다.
자바스크립트는 인터프리터 언어입니다. 인터프리터 언어 특성상 실행 속도가 느릴 것 같지만 최근 웹 브라우저 대부분에는 실행 시간에 자바스크립트 코드를 컴파일하는 JIT 컴파일러가 내장되어 있어 속도가 매우 빨라졌습니다.

2. 동적 프로토타입 기반 객체 지향 언어
Java 같은 경우 클래스를 이용하여 객체를 생성하는 클래스 기반 객체 지향 언어입니다. 자바스크립트는 클래스가 아닌 프로토타입을 상속하는 프로토타입 기반 객체 지향 언어입니다. 때문에 자바스크립트에서는 객체를 생성한 후에도 프로퍼티와 메서드를 동적으로 추가하거나 삭제할 수 있습니다.

3. 동적 타입 언어
자바스크립트는 특정한 변수 타입이 없습니다. 프로그램을 실행하는 도중 변수에 저장되는 데이터 타입이 동적으로 바뀔 수 있습니다.

4. 함수가 일급 객체이다.
자바스크립트의 함수는 객체입니다. 함수에 함수를 인자로 넘길 수 있고 이 특성이 함수가 일급 객체인 이유입니다. 이 특성을 활용해 고차 함수를 구현할 수 있는 함수형 프로그래밍이 이루어질 수 있습니다.

5. 함수가 클로저를 정의한다.
자바스크립트의 함수는 클로저를 정의합니다. 클로저로 변수를 은닉하거나 영속성을 보장하는 등 다양한 기능을 구현할 수 있습니다.

자바스크립트의 기술적 요소
자바스크립트는 3가지 기술적 요소로 구성되어있습니다.

1. ECMAScript(코어 언어)
이는 자바스크립트의 핵심 기술입니다. ECMA라는 조직의 위원회가 표준화 작업을 하고있고 이를 공개합니다. 자바스크립트를 배우기 위해서는 먼저 코어 언어의 내용부터 제대로 이해해야합니다.

2. Client 측의 고유한 기술 요소
웹 브라우저에서 동작하는 자바스크립트를 클라이언트 측 자바스크립트라고 부릅니다. 이는 ECMAScript 코어 언어와 웹 브라우저의 API로 구성되어 있습니다. 주요 웹브라우저 API는

window interface : 자바스크립트로 브라우저 또는 창을 조작하는 기능 제공
DOM : 자바스크립트로 HTML 문서의 요소를 제어하는 기능을 제공
XMLHttpRequest : 서버와 비동기로 통신하는 기능을 제공

뿐만 아니라 HTML5에 규정된 다양한 API도 사용할 수 있습니다.

3. Server 측의 고유한 기술 요소
웹 서버에서 동작하는 자바스크립트를 서버 측 자바스크립트라고 합니다. Node.js가 웹 애플리케이션을 만드는데 자주 사용됩니다.

자바스크립트는 강력한 프로그래밍 언어입니다. ES6 이후 매년 언어의 사양을 개정하기로 했습니다. 뿐만 아니라 ES6에서 발표된 이터레이터와 제너레이터 같은 경우 새로운 프로그래밍 패러다임을 제시합니다. 사양이 개정되면 많은 웹브라우저에 빠르게 구현되고 있습니다.

변수란?

변수는 값을 담기 위해 이름을 붙인 상자입니다. 변수를 선언하면 컴퓨터의 메모리에 일정한 크기의 영역으로 할당됩니다.
변화 시키는 값을 만들어 알고리즘을 통해 프로그램이 의도한 목적을 달성합니다.

자바스크립트에서 변수 선언

자바스크립트는 다른 프로그래밍 언어와 다르게 변수 선언자는 var 하나 뿐 입니다. 이를 활용해 모든 데이터 타입의 값을 저장할 수 있습니다. 만약 변수를 선언하기만 하고 값을 지정해 주지 않는 다면 그 변수는 undefined 라는 값을 가지게 됩니다.

var a; => console.log(a); => undefined
var a=2; => console.log(a); => 2

자바스크립트 변수 선언 생략

변수 x에 대한 선언을 하지 않고 console.log(x); 를 하게되면 참조 오류가 발생하게 됩니다.
하지만 var를 생략하여 다음과 같이 활용할 수 있습니다.
x=2;
console.log(x); // -> 2

이렇게 변수를 선언하지 않은 상태에서 값을 대입하면 자바스크립트 엔진이 변수를 자동으로 전역 변수로 선언하게 됩니다.
하지만 변수를 선언하지 않는 것은 많은 버그의 원인이 될 수 있기때문에 권장하지 않습니다.

자바스크립트 변수 끌어올림과 변수 중복 선언

자바스크립트는 매우 특이한 특징을 가지고 있습니다.
이는 바로 변수 끌어올림 인데요.
만약 C에서

printf(a);
int a;

라는 순서로 코드 작성 시 오류가 발생하게 됩니다.

하지만 자바스크립트는 

console.log(a);
var a;

라는 순서로 코드를 작성해도 오류가 발생하지 않거니와 콘솔에는 undefined가 정상적으로 출력됩니다.

자바스크립트는 변수의 선언을 가장 먼저 처리하는데요.
이는 선언에만 해당할 뿐 값의 대입에는 해당되지 않습니다.

즉,
console.log(a);
var a=5;
console.log(a);

라는 코드 작성 시 
undefined
5
가 출력되게 됩니다.

하지만 변수의 끌어올림은 다른 사용자 혹은 다른 프로그래밍 언어의 사용자에게 매우 불편할 수 있습니다.
따라서 변수의 선언은 코드 최상단에 위치할 수 있도록 권장합니다.

데이터 타입이란?

데이터 타입이란 숫자나 문자열처럼 변수에 저장하는 데이터 종류입니다.
다른 언어들은 변수의 타입과 일치하는 데이터만 저장할 수 있지만 
자바스크립트는 동적 타입 언어이기 타입에 상관하지 않고 저장할 수 있습니다.
따라서 프로그램을 실행할 때 발생하는 타입 변환에 주의하여 변수에 어떤 타입의 데이터가 저장되는지 잘 확인해야 합니다.

자바스크립트가 처리할 수 있는 데이터 타입은 크게 두가지입니다.
원시타입 객체타입 입니다.
원시타입에는 숫자, 문자열, 논리값, 특수한 값(undefined, null)과 심벌 값이 있습니다.
원시타입 데이터는 불변값으로 정의되어 있습니다.

원시타입에 속하지 않는 값들은 객체라고 표현합니다. 객체는 변수 여러개가 모여서 만들어집니다.
객체 안에 저장된 값은 바꿀 수 있습니다.
객체는 참조 타입입니다. 객체 타입의 값을 변수에 대입하면 변수에는 객체에 대한 참조가 할당됩니다.(배열, 함수, 정규 표현식 등)

자바스크립트 숫자


자바스크립트는 모든 숫자를 64bit 부동소수점으로 표현합니다.
단, 배열 인덱스와 비트 연산만큼은 32bit 정수로 처리합니다.
프로그램에 직접 작성할 수 있는 상수 값을 리터럴 이라고 표현합니다. 숫자를 표현하는 리터럴에는 정수 리터럴과 부동소수점 리터럴이 있습니다.

자바스크립트 문자열


자바스크립트의 문자열은 길이가 16비트인 유니코드 문자를 나열한 것으로 문자 대부분을 표현할 수 있습니다.
' 혹은 " 로 묶어 사용합니다.
자바스크립트를 HTML 요소에 끼워 넣을 때 자바스크립트 프로그램 같은 경우는 작은 따옴표를 사용하는 것을 권장합니다.

특수한 문자들의 경우 이스케이프 시퀀스를 사용하여 표현해야한다는 특징 또한 가지고 있습니다.

자바스크립트 논리값


논리값은 조건식이 참인지 거짓인지 표현하기 위해 사용합니다. true와 false 두 가지 종류가 있습니다.

자바스크립트 특수한 값


값이 없음을 표현하는 값은 undefined와 null이 있습니다.
undefined는 정의되지 않은 상태인데요.

- 값을 아직 할당하지 않은 변수의 값
- 없는 개체의 프로퍼티를 읽으려고 시도했을 때의 값
- 없는 배열의 요소를 읽으려고 시도했을 때의 값
- 아무것도 반환하지 않는 함수가 반환하는 값
- 함수를 호출했을 때 전달받지 못한 인수의 값

등을 자바스크립트 엔진이 undefined로 초기화 합니다.

null은 아무것도 없음을 값으로 표현한 리터럴입니다.
주로 검색 시 검색 결과가 없을 때 null을 사용하여 분기처리 해주고 합니다.

ES6 부터의 데이터 타입


ES6 에 추가된 데이터 타입에는 심벌 과 템플릿 리터럴이 있습니다.

심벌은 ES6부터 새롭게 추가된 원시 값입니다. 심벌은 자기 자신을 제외한 그 어떤 값과도 다른 유일무이한 값입니다.

선언 형식은 

var sym1 = Symbol();

입니다.

심볼 함수는 호출 될 때 마다 새로운 값을 만듭니다.

괄호 안에 인수 전달 시 생성된 심벌의 설명을 덧붙일 수 있습니다.

심볼을 사용하는 가장 큰 이유는 충돌 위험이 없기 때문입니다.
또한 값 자체의 의미가 없고 상수의 이름 자체에 의미가 있는 경우 사용하는 것이 좋습니다.

심볼 관련 참고 블로그 : https://medium.com/@hyunwoojo/javascript-symbol-%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-6aa5903fb6f1

템플릿 리터럴 또한 ES6부터 추가되었습니다. 
템플릿이란 일부만 변경해서 반복하거나 재사용할 수 있는 틀입니다.
템플릿 리터럴을 사용하여 표현식의 값을 문자열에 추가하거나 여러 줄의 문자열을 표현할 수 있습니다.

기본적으로 따옴표가 아닌 `` 역따옴표로 묶은 문자열입니다.
가장 큰 특징은 이스케이프 시퀀스를 사용하지 않아도 개행 만으로 줄바꿈을 할 수 있다는 것과
변수등의 값인 플레이스 홀더를 넣을 수 있다는 점입니다.

var a=2, b=3 일때
2는
3이 아닙니다.

라는 문자열을 만들고 싶다면
기존에는
console.log(a+"는\n" + b + "이 아닙니다.")

이 되지만 템플릿 리터럴을 통해
console.log(`${a}는
${b}이 아닙니다.`)

라고 표현이 가능해졌습니다.

객체란?

객체는 이름과 값을 한 쌍으로 묶은 데이터를 여러 개 모은 것입니다. 데이터 여러 개를 하나로 모은 복합 데이터입니다.
객체에 포함된 데이터 한 쌍(이름, 값)을 프로퍼티 라고 부릅니다.
자바스크립트에서 객체를 생성할 때 하나는 객체 리터럴을 사용하는 방법 나머지 하나는 생성자 함수를 사용하는 방법이 있습니다.

객체 리터럴로 객체 생성하기


var card = {suit:"하트", rank:"A"}

여기서 {...} 부분이 객체 리터럴 입니다. 이 객체 리터럴을 변수 card에 대입하고 있습니다.
프로퍼티 값에는 모든 데이터 타입의 값과 표현식을 대입할 수 있습니다.

변수에 대입된 객체 안의 프로퍼티 값을 읽거나 쓸 때는 마침표 혹은 대괄호 연산자를 사용합니다.

card.suit -> 하트
card["suit"] -> 하트

만약 객체에 없는 프로퍼티를 읽으려고 시도하면 undefined를 반환합니다.

객체 리터럴 안에 어떠한 프로퍼티도 작성하지 않으면 빈 객체가 생성됩니다.

프로퍼티 추가와 삭제


없는 프로퍼티 이름에 값을 대입하면 새로운 프로퍼티가 추가됩니다.
card.value = 14;
card -> {suit:"하트", rank:"A",value:14}

delete 연산자를 사용하면 프로퍼티를 삭제할 수 있습니다.

delete card.rank;
card -> {suit:"하트",value:14}

in 연산자로 프로퍼티가 있는 지 확인하기

in 연산자를 통해 프로퍼티가 객체 내에 존재하는 지 확인할 수 있습니다. 
console.log("suit" in card); -> true
console.log("color" in card); -> false

다만 in 연산자는 객체가 가진 프로퍼티와 객체가 상속받는 모든 프로퍼티를 조사한다는 점에서 주의할 필요가 있습니다.
객체는 Object 객체를 상속받게 되는데 때문에
console.log("toString" in card); -> true
라는 결과가 나오게 됩니다.

자바스크립트에서 함수란?
일반 수학 공식과 같이 입력을 받으면 특정한 알고리즘 후 출력을 한다.
자바스크립트에서 입력값은 인수 라고 부르고 출력값은 반환값 이라고 부른다.

함수 정의하기

함수는 function 키워드를 사용해서 정의할 수 있습니다. 

function square(x) {return x*x;}

함수 이름은 변수 이름과 마찬가지로 모든 식별자를 사용할 수 있습니다.
하지만 가독성과 유지 보수성을 위해 함수에 이름을 잘 붙이는 것이 중요합니다.
함수 이름은 일반적으로 동사 또는 동사로 시작되는 어휘로 만듭니다.

function saveImage(img){...}
function getMousePosition(event){...}
function load_file(){...}

함수 호출

함수 호출을 위해서는 함수 이름 뒤에 소괄호로 인수를 묶어 입력합니다.
square(3);
이때 함수 호출 할 때 전달하는 값을 인수( 여기선 3) 
함수 정의문의 인수를 인자
라고 부릅니다.

인수
함수는 인수를 여러 개 받을 수 있고 이는 쉼표로 구분합니다.
또한 인수가 없는 상태로도 함수를 호출할 수 있습니다.

함수의 실행 흐름은 다음과 같습니다.
1. 호출한 코드에 있는 인수가 함수 정의문에 인자로 대입
2. 함수 정의문의 중괄호 안에 작성된 프로그램이 순차적으로 실행됨
3. return 문이 실행되면 호출한 코드로 돌아감.
4. return 문이 실행되지 않은 상태로 함수의 마지막까지 실행되면, 호출한 코드로 돌아가고 함수의 반환값은 undefined가 됨

자바스크립트 엔진은 변수 선언문과 마찬가지로 함수 선언문을 프로그램의 첫머리로 끌어올리기 때문에 함수 선언문은 프로그램의 어떤 위치에도 작성할 수 있습니다.

값으로서의 함수
자바스크립트에서는 함수가 객체입니다. 선언문을 통해 함수를 선언하면 내부적으로는 함수 이름을 변수 이름으로 한 변수와 함수 객체가 만들어지고, 그 변수에 함수 객체의 참조가 저장됩니다.
square -> function(x){return x*x;}

값의 전달과 참조 전달
함수는 원시 값을 인수로 넘겼을 때와 객체를 인수로 넘겼을 때 다르게 동작합니다.

우선 인수가 원시 값일 때 입니다.
function add1(x) {return x=x+1;}
var a = 3;
var b = add1(a);
console.log(`a=${a}, b=${b}`); ==> a=3, b=4
원시값을 전달할 때는 변수 a의 복사본인 값 자체만이 인자에 전달됩니다.
이를 값을 전달이라고 부릅니다.
a는 add1이라는 함수로는 바꿀 수 없습니다.

다음은 인수가 객체일 때 입니다.

function add1(p){p.x=p.x+1; p.y=p.y+1; return p;}
var a = {x:3,y:4};
var b = add1(a);
console.log(a,b); => Object{x:4,y:5},Object{x:4,y:5}
이때 변수 a의 값이 바뀐 것을 확인 할 수 있습니다.
이는 변수 a와 인자 p가 똑같은 객체를 참조하고 있기때문입니다.
즉 a라는 변수명에 참조되어있던 객체는 p라는 변수명에서도 똑같이 참조됩니다.
이는 함수의 참조 전달 뿐 아니라 객체 참조를 할 경우 모두 적용됩니다.

변수의 유효범위
변수에 접근할 수 있는 범위를 변수의 유효 범위라고 표현합니다.
이는 2가지로 나뉘게 되는데
어휘적 범위 : 프로그램의 구문만으로 유효 범위를 정함
동적 범위 : 프로그램 실행 중에 유효 범위를 정함

자바스크립트는 어휘적 범위를 채택하고있습니다.
자바스크립트 변수는 유효 범위에 따라
전역변수 와 지역변수 로 나뉘게 됩니다.
전역변수는 함수 바깥에서 선언된 변수로 유효 범위가 전체 프로그램입니다.
지역변수는 함수 안에서 선언된 변수와 함수 인자로 유효 범위는 변수가 선언된 함수 내부입니다.

변수에 유효범위가 있는 이유는 프로그램의 다른 부분에서 선언된 이름이 같은 변수와 충돌하지 않도록 하기 위해서입니다.
하지만 만약 전역변수 이름과 지역변수 이름이 같아지면 두 변수는 충돌하게 되고 이때는 전역변수 대신 지역변수를 사용하게 됩니다.

블록 유효 범위 let 과 const

let과 const 는 ES6 부터 추가된 블록 유효 범위를 갖는 변수 선언 방식입니다.

블록 유효 범위를 가진 변수는 중괄호 안에서만 유효합니다.

let은 변수를 선언하고
const는 한 번만 할당할 수 있는 상수를 선언합니다.

let은 var와 사용법이 매우 유사합니다.
다만 자바스크립트 엔진 처리에서 차이점이 있습니다.
var의 경우 변수 끌어올림을 통해 가장 먼저 선언하고 그 값을 undefined로 초기화 합니다.
반면에 let은 변수 끌어올림을 하지만 선언문을 평가하기 전에는 값을 초기화하지 않습니다.
때문에 
console.log(a);
let a = 0;
이 때 참조 오류가 발생하게 됩니다.
이때 let a와 a=0 사이의 자바스크립트 엔진 평가 기간을 TDZ(Temporal Dead Zone)이라고 합니다.

const 선언자는 블록 유효 범위를 가지면서 한 번만 할당할 수 있는 변수(상수)를 선언합니다.
const 선언자는 반드시 초기화 해주는 작업이 필요합니다.

const문으로 선언한 변수에 다시 대입을 시도하면 타입 오류가 발생합니다.

원시타입인 상수 값은 수정할 수 없지만 상수 값이 객체이거나 배열일 경우에는 프로퍼티 또는 프로퍼티 값을 수정할 수는 있습니다.

함수 리터럴로 함수 정의하기

함수는 함수 리터럴로도 정의할 수 있습니다. 
ex) var square = function(x) { return x*x };

이런 함수 리터럴은 이름이 없는 함수이므로 익명 함수 또는 무명 함수라고 부릅니다.
함수 선언문과의 차이점은 함수 선언문은 변수 끌어올림같이 함수 끌어올림을 하지만
함수 리터럴로 정의한 함수는 끌어올리지 않는 다는 점입니다.
함수 리터럴로 정의한 익명 함수는 변수에 할당한 후에야 비로소 square라는 이름을 갖게 되고, 그 이름으로 호출할 수 있게 됩니다.
때문에 함수를 정의하지 않은 상태에서 함수를 사용하려고 하면 타입 오류가 발생합니다.

즉 리터럴로 정의할 경우
1. 변수 끌어올림을 통해 square는 undefined로 초기화
2. square은 익명함수임을 판단한 후 부터 함수로서 사용가능
입니다.

익명함수에도 이름을 붙일 수 있습니다.
var square = function sq(x) { return x*x };
하지만 sq는 이 익명함수 내부에서 밖에 호출할 수 없습니다.

Java나 C++은 객체를 여러 개 생성하는 수단으로 클래스를 제공하고 있습니다.
하지만 자바스크립트에는 클래스가 없고 생성자라고 하는 함수로 객체를 생성할 수 있습니다.
function Card(suit,rank){
	this.suit = suit;
    	this.rank = rank;
}
생성자로 객체를 생성할 때는 new 연산자를 사용합니다.
var card = new Card("하트","A");
이 처럼 new 연산자로 객체를 생성할 것이라 기대하고 만든 함수를 생성자라고 부릅니다.
생성자 이름은 관럐적으로 그것이 생성자임을 알리기 위해 첫 글자는 대문자로 쓰고 있습니다.

이처럼 new 연산자로 생성한 객체를 생성자의 인스턴스라고 부르고 있습니다.
OOP에서의 인스턴스는 클래스로 생성한 실체를 뜻합니다.
하지만 자바스크립트에서는 클래스가 존재하지 않기 때문에 엄밀히 말하자면 인스턴스가 아니지만 관례상 그렇게 부르고 있습니다.

자바스크립트 배열 리터럴로 생성하기
배열 리터럴은 쉼표로 구분한 값을 대괄호로 묶어서 표현합니다.
여기서 배열 값 하나를 배열 요소라고 부르며 배열 요소의 순서대로 붙은 0부터의 값은 요소 번호 혹은 인덱스라고 부릅니다.
자바스크립트의 배열 또한 객체 타입이므로 배열을 변수에 대입하면 배열의 참조가 변수에 저장됩니다.

length 프로퍼티
일반적으로 배열의 length 프로퍼티에는 배열 요소의 최대 인덱스 값 +1 이 담겨있습니다.
이를 배열 길이라고 부릅니다.
이때 length 프로퍼티에 현재의 배열 요소 개수보다 작고 0보다 큰 정수 값을 대입하면 배열 길이가 줄어듭니다.
즉, 배열 길이를 넘는 인덱스 번호에 할당된 배열 요소는 삭제됩니다.

배열은 Array 생성자로도 생성할 수 있습니다.
일반적인 방법은 동일합니다.
var a = new Array(2,5) => [2,5]
하지만 생성자의 인수가 1개고 그 값이 양의 정수일 경우 인수는 배열의 길이를 뜻하게 되고 배열이 그 길이만큼 생성됩니다.
양의 정수가 아닐때는 오류가 발생합니다.
var a = new Array(3); => 길이가 3인 배열

자바스크립트의 배열은 객체입니다.
C나 Java에서는 배열의 경우 연속된 공간에 차례대로 배치되어있습니다.
하지만 자바스크립트의 배열은 객체로 이를 흉내낸것에 불가능합니다.
즉 우리가 인덱스 혹은 요소 번호라고 불리우는 것도 프로퍼티의 이름에 불과합니다.
때문에 자바스크립트는 다음과 같은 표현도 가능합니다.
a["0"]=1;

객체의 특성을 살려 배열 요소의 추가와 삭제에 응용할 수 있습니다.
var a = ["A","B","C"];
a[3] = "D";
console.log(a); // -> ["A","B","C","D"]
또는 Push 메서드를 통해 요소를 배열 끝에 추가할 수 있습니다.
var a = ["A","B","C"];
a.push("D");
console.log(a); // -> ["A","B","C","D"]
객체와 마찬가지로 delete를 통해 특정 배열 요소를 삭제할 수 있습니다.
하지만 이때 값이 사라지는 것일뿐 전체 배열의 길이는 바뀌지 않습니다.
delete a[1];
console.log(a); // -> ["A",undefined,"C","D"]

